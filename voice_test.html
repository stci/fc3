<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>Speech Synthesis Demo (Smart Voice Selection)</title>
<style>
body { font-family: Arial, sans-serif; margin: 20px; }
#voices { margin-top: 10px; }
.auto-selected { padding: 5px; font-weight: bold; color: green; }
</style>
</head>
<body>

<h2>Speech Synthesis Demo</h2>

<label>Language:</label>
<select id="lang">
  <option value="en-GB">English (en-GB)</option>
  <option value="de-DE">German (de-DE)</option>
</select>

<br><br>

<label>Text to speak:</label><br>
<textarea id="text" rows="4" cols="60">Hello! This is a test.</textarea>

<br><br>

<div id="auto" class="auto-selected"></div>

<label>Available voices:</label>
<div id="voices"></div>

<br>
<button id="speakBtn">Speak</button>

<script>
/* ================================================================
   SMART CROSS-PLATFORM BEST VOICE SELECTOR
   ================================================================ */
function getBestVoice(lang, callback) {
  const ua = navigator.userAgent;
  const isIOS = /iPad|iPhone|iPod/.test(ua);

  const iOSBestVoice = {
    "en-gb": "daniel"
  };

  function loadVoices() {
    let voices = speechSynthesis.getVoices();

    if (isIOS && !voices.length) {
      let attempts = 0;
      const interval = setInterval(() => {
        voices = speechSynthesis.getVoices();
        attempts++;
        if (voices.length || attempts > 20) {
          clearInterval(interval);
          selectVoice(voices);
        }
      }, 100);
    } else {
      selectVoice(voices);
    }
  }

  function selectVoice(voices) {
    if (!voices.length) return callback(null);

    const langPrefix = lang.toLowerCase();

    function isBadMultilingual(v) {
      const n = v.name.toLowerCase();
      return n.includes("multilingual") || n.includes("universal");
    }

    /* =======================================================
       iOS SPECIAL LOGIC (BEST VOICES FOR iPad/iPhone)
       ======================================================= */
    if (isIOS) {
      /* ---- GERMAN ---- */
      if (langPrefix === "de-de") {
        const iOSGermanPriority = ["anna", "markus", "petra", "klara"];

        // 1) Exact locale first
        for (const name of iOSGermanPriority) {
          const v = voices.find(x =>
            x.lang.toLowerCase() === "de-de" &&
            x.name.toLowerCase().includes(name)
          );
          if (v) return callback(v);
        }

        // 2) Fallback ANY de-de (non-bad)
        let v = voices.find(x =>
          x.lang.toLowerCase() === "de-de" && !isBadMultilingual(x)
        );
        if (v) return callback(v);

        // 3) Fallback de-AT / de-CH
        v = voices.find(x => x.lang.toLowerCase() === "de-at");
        if (v) return callback(v);
        v = voices.find(x => x.lang.toLowerCase() === "de-ch");
        if (v) return callback(v);
      }

      /* ---- ENGLISH ---- */
      if (langPrefix === "en-gb") {
        const target = "daniel";
        const v = voices.find(x =>
          x.lang.toLowerCase() === "en-gb" &&
          x.name.toLowerCase().includes(target)
        );
        if (v) return callback(v);
      }
    }

    /* =======================================================
       MICROSOFT EDGE "ONLINE NATURAL" VOICES
       ======================================================= */
    if (/Edg\//.test(ua)) {
      const v = voices.find(x =>
        x.lang.toLowerCase() === langPrefix &&
        !isBadMultilingual(x) &&
        x.name.toLowerCase().includes("online") &&
        x.name.toLowerCase().includes("natural")
      );
      if (v) return callback(v);
    }

    /* =======================================================
       ANDROID EXACT MATCH
       ======================================================= */
    const androidExact = voices.find(v =>
      v.lang.toLowerCase() === langPrefix &&
      !isBadMultilingual(v)
    );
    if (androidExact) return callback(androidExact);

    /* =======================================================
       PREFERRED VOICES
       ======================================================= */
    const preferred = {
      "de-de": ["katja", "conrad"],
      "en-gb": []
    }[langPrefix] || [];

    let v = voices.find(x =>
      x.lang.toLowerCase() === langPrefix &&
      !isBadMultilingual(x) &&
      preferred.some(p => x.name.toLowerCase().includes(p))
    );
    if (v) return callback(v);

    /* =======================================================
       NORMAL FALLBACKS
       ======================================================= */
    v = voices.find(x =>
      x.lang.toLowerCase() === langPrefix &&
      !isBadMultilingual(x)
    );
    if (v) return callback(v);

    if (langPrefix === "de-de") {
      v = voices.find(x => x.lang.toLowerCase() === "de-at");
      if (v) return callback(v);

      v = voices.find(x => x.lang.toLowerCase() === "de-ch");
      if (v) return callback(v);
    }

    v = voices.find(x => x.lang.toLowerCase().startsWith(langPrefix));
    if (v) return callback(v);

    callback(null);
  }

  if (speechSynthesis.getVoices().length > 0) loadVoices();
  else speechSynthesis.addEventListener("voiceschanged", loadVoices, { once: true });
}

/* ================================================================
   DEMO UI LOGIC
   ================================================================ */
const langSelect = document.getElementById("lang");
const voicesDiv = document.getElementById("voices");
const autoDiv = document.getElementById("auto");
let selectedVoice = null;

function refreshVoiceUI() {
  const lang = langSelect.value;
  const langLower = lang.toLowerCase();

  getBestVoice(langLower, best => {
    selectedVoice = best;

    autoDiv.textContent = best
      ? "Auto-selected voice: " + best.name + " (" + best.lang + ")"
      : "No auto-selected voice found";

    const voices = speechSynthesis.getVoices();

    // FIRST: EXACT locale
    const exact = voices.filter(v =>
      v.lang.toLowerCase() === langLower
    );

    // SECOND: RELATED languages (starts with "en" or "de")
    const related = voices.filter(v =>
      v.lang.toLowerCase().startsWith(langLower.substring(0,2)) &&
      v.lang.toLowerCase() !== langLower
    );

    const filtered = [...exact, ...related];

    voicesDiv.innerHTML = "";

    filtered.forEach(v => {
      const id = "v_" + Math.random();
      const checked =
        selectedVoice &&
        selectedVoice.name === v.name &&
        selectedVoice.lang.toLowerCase() === langLower
          ? "checked"
          : "";

      voicesDiv.innerHTML += `
        <label>
          <input type="radio" name="voice" value="${v.name}" ${checked}>
          ${v.name} (${v.lang})
        </label><br>
      `;
    });

    voicesDiv.querySelectorAll("input[name=voice]").forEach(r => {
      r.addEventListener("change", () => {
        const voices = speechSynthesis.getVoices();
        selectedVoice = voices.find(v => v.name === r.value);
      });
    });
  });
}

langSelect.addEventListener("change", refreshVoiceUI);
speechSynthesis.addEventListener("voiceschanged", refreshVoiceUI);

document.getElementById("speakBtn").addEventListener("click", () => {
  const text = document.getElementById("text").value;
  const u = new SpeechSynthesisUtterance(text);
  if (selectedVoice) u.voice = selectedVoice;
  speechSynthesis.speak(u);
});

// Initial load
refreshVoiceUI();
</script>

</body>
</html>
